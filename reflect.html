<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - mirror</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
        <link type="text/css" rel="stylesheet" href="main.css" />
        <style>
            body {
                color: #444;
            }
            a {
                color: #08f;
            }
        </style>
    </head>
    <body>
        <div id="container"></div>
        <div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - mirror</div>

        <!-- Import maps polyfill -->
        <!-- Remove this when import maps will be widely supported -->
        <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

        <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.module.js",
                    "three/addons/": "./jsm/"
                }
            }
        </script>

        <script type="module">
            import * as THREE from "three";

            import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { Reflector } from "three/addons/objects/Reflector.js";

            THREE.ColorManagement.enabled = false; // TODO: Confirm correct color management.

            let camera, scene, renderer;

            let cameraControls;

            let sphereGroup, smallSphere;

            let groundMirror, verticalMirror;
            const loader = new FBXLoader();
            let mixer = new THREE.AnimationMixer();
            let clock = new THREE.Clock();

            init();
            animate();

            function init() {
                const container = document.getElementById("container");

                // renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                // scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);

                // camera
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
                camera.position.set(0, 75, 160);

                cameraControls = new OrbitControls(camera, renderer.domElement);
                cameraControls.target.set(0, 40, 0);
                cameraControls.maxDistance = 400;
                cameraControls.minDistance = 10;
                cameraControls.update();

                //

                const planeGeo = new THREE.PlaneGeometry(100.1, 100.1);

                // reflectors/mirrors

                let geometry, material;

                let outerR = 18;
                let innerR = 14;
                let h = 0.5;
                let g = cylinderLathe(outerR, innerR, h);
                function cylinderLathe(R, r, h) {
                    let halfH = h * 0.5;
                    let points = [new THREE.Vector2(r, -halfH), new THREE.Vector2(R, -halfH), new THREE.Vector2(R, halfH), new THREE.Vector2(r, halfH), new THREE.Vector2(r, -halfH)];
                    let circle = new THREE.LatheGeometry(points, 72);

                    return circle;
                }

                geometry = new THREE.CircleGeometry(40, 64);
                groundMirror = new Reflector(g, {
                    clipBias: 0.003,
                    textureWidth: window.innerWidth * window.devicePixelRatio,
                    textureHeight: window.innerHeight * window.devicePixelRatio,
                    color: 0xb5b5b5,
                });
                scene.add(groundMirror);

                // geometry = new THREE.PlaneGeometry(100, 100);
                // verticalMirror = new Reflector(geometry, {
                //     clipBias: 0.003,
                //     textureWidth: window.innerWidth * window.devicePixelRatio,
                //     textureHeight: window.innerHeight * window.devicePixelRatio,
                //     color: 0xc1cbcb,
                // });
                // verticalMirror.position.y = 50;
                // verticalMirror.position.z = -50;
                // scene.add(verticalMirror);

                // sphereGroup = new THREE.Object3D();
                // scene.add(sphereGroup);

                // geometry = new THREE.CylinderGeometry(0.1, 15 * Math.cos((Math.PI / 180) * 30), 0.1, 24, 1);
                // material = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x8d8d8d });
                // const sphereCap = new THREE.Mesh(geometry, material);
                // sphereCap.position.y = -15 * Math.sin((Math.PI / 180) * 30) - 0.05;
                // sphereCap.rotateX(-Math.PI);

                // geometry = new THREE.SphereGeometry(15, 24, 24, Math.PI / 2, Math.PI * 2, 0, (Math.PI / 180) * 120);
                // const halfSphere = new THREE.Mesh(geometry, material);
                // halfSphere.add(sphereCap);
                // halfSphere.rotateX((-Math.PI / 180) * 135);
                // halfSphere.rotateZ((-Math.PI / 180) * 20);
                // halfSphere.position.y = 7.5 + 15 * Math.sin((Math.PI / 180) * 30);
                // sphereGroup.add(halfSphere);

                loader.load("data/CuteBox.fbx", (object) => {
                    object.scale.multiplyScalar(0.1);
                    object.position.set(-10, 0, 0);

                    // mixer = new THREE.AnimationMixer(object);
                    // const action = mixer.clipAction(object.animations[0]);
                    // action.play();
                    object.name = "avatar";
                    scene.add(object);

                    clock = new THREE.Clock();
                });

                // walls
                const planeTop = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xffffff }));
                planeTop.position.y = 100;
                planeTop.rotateX(Math.PI / 2);
                scene.add(planeTop);

                const planeBottom = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xffffff }));
                planeBottom.rotateX(-Math.PI / 2);
                scene.add(planeBottom);

                const planeFront = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xbbbbfe }));
                planeFront.position.z = 50;
                planeFront.position.y = 50;
                planeFront.rotateY(Math.PI);
                scene.add(planeFront);

                const planeRight = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                planeRight.position.x = 50;
                planeRight.position.y = 50;
                planeRight.rotateY(-Math.PI / 2);
                scene.add(planeRight);

                const planeLeft = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
                planeLeft.position.x = -50;
                planeLeft.position.y = 50;
                planeLeft.rotateY(Math.PI / 2);
                scene.add(planeLeft);

                // lights
                const mainLight = new THREE.PointLight(0xffffff, 1.5, 250);
                mainLight.position.y = 60;
                scene.add(mainLight);
                const pointLightHelper1 = new THREE.PointLightHelper(mainLight, 10, "red");
                // scene.add(pointLightHelper1);

                window.addEventListener("resize", onWindowResize);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

                groundMirror.getRenderTarget().setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
                verticalMirror.getRenderTarget().setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
            }

            function animate() {
                requestAnimationFrame(animate);

                const timer = Date.now() * 0.01;

                // sphereGroup.rotation.y -= 0.002;

                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>
