<head>
    <style>
        body {
            margin: 0;
            box-sizing: content-box;
        }
        #drop {
            position: absolute;
            z-index: 0;
        }
        .userInfo {
            position: absolute;
            z-index: 1;
            width: 100%;
            display: flex;
            box-sizing: border-box;
            padding: 0 32px;
            -webkit-box-align: center;
            align-items: center;
            -webkit-box-pack: justify;
            justify-content: space-between;
            top: 20px;
        }
        .userInfo .row1 {
            background: #fff;
            width: 100%;
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="userInfo">
        <div class="row1">
            <button class="">test1</button>
        </div>
    </div>
    <canvas id="drop"></canvas>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { MapControls } from "three/addons/controls/MapControls.js";
        import { FBXLoader } from "three/examples/jsm/loaders/FBXLoader.js";
        import { Reflector } from "three/addons/objects/Reflector.js";

        const scene = new THREE.Scene();
        let camera,
            renderer,
            controls,
            circle = null;
        const loader = new FBXLoader();
        const group = new THREE.Group();
        var targetRotationX = -0.01;
        var targetRotationOnMouseDownX = 0;

        var mouseX = 0;
        var mouseXOnMouseDown = 0;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;

        var slowingFactor = 0.1;
        // let autoRotate = true;

        init();
        // ground();
        setCircle();
        setDrop();
        render();

        scene.add(new THREE.GridHelper(30, 30, 0xff80ed, 0x444444));

        function init() {
            const canvas = document.getElementById("drop");

            // render hive
            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            // document.querySelector(".wrapper").appendChild(renderer.domElement);
            //
            // camera
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.01, 10000);
            // camera.position.set(0, 20, 0);
            camera.position.set(0, 8, 10);

            // light
            let light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(-5, 10, -5);
            light.castShadow = true;
            light.shadow.mapSize.width = 1042;
            light.shadow.mapSize.height = 1042;
            scene.add(light);
            scene.add(new THREE.DirectionalLightHelper(light, 1, "red"));

            const mainLight = new THREE.PointLight(0xffffff, 1.5, 250);
            mainLight.position.y = 60;
            scene.add(mainLight);
            const pointLightHelper1 = new THREE.PointLightHelper(mainLight, 10, "red");
            scene.add(pointLightHelper1);

            scene.add(new THREE.AmbientLight(0xaaaaaa, 0.7));

            // controls
            controls = new MapControls(camera, renderer.domElement);
            // controls.enableDamping = true;
            // controls.enablePan = false;
            // controls.enableZoom = false;
            controls.target.set(20, 0, 3);

            // event
            canvas.addEventListener("touchstart", onDocumentMouseDown);
        }

        let timer;
        function onDocumentMouseDown(event) {
            console.log("touchstart");
            event.preventDefault();

            // autoRotate = false;
            // if (timer) {
            //     clearTimeout(timer);
            // }
            // timer = setTimeout(() => {
            //     autoRotate = true;
            // }, 3000);

            document.addEventListener("touchmove", onDocumentMouseMove);
            document.addEventListener("touchend", onDocumentMouseUp);
            // document.addEventListener("mouseout", onDocumentMouseUp);

            mouseXOnMouseDown = event.touches[0].clientX - windowHalfX;
        }

        function onDocumentMouseMove(event) {
            console.log("touchmove");
            mouseX = event.touches[0].clientX - windowHalfX;
            console.log(mouseX);
            targetRotationX = -(mouseX - mouseXOnMouseDown) * 0.00005;
        }

        function onDocumentMouseUp(event) {
            console.log("touchend");
            document.removeEventListener("touchmove", onDocumentMouseMove);
            document.removeEventListener("touchend", onDocumentMouseUp);
            // document.removeEventListener("mouseout", onDocumentMouseUp);
        }

        function ground() {
            // const geo = new THREE.PlaneGeometry(30, 30);
            // const mat = new THREE.MeshStandardMaterial({
            //     color: "#6574BE",
            //     side: THREE.DoubleSide,
            //     // opacity: 0.5,
            //     // transparent: true,
            // });
            // // shadow blur
            // //https://github.com/mrdoob/three.js/blob/master/examples/webgl_shadow_contact.html

            // const ground = new THREE.Mesh(geo, mat);
            // ground.rotation.x = Math.PI * 0.5;
            // ground.receiveShadow = true;
            // scene.add(ground);

            const geo = new THREE.SphereGeometry(30, 30);
            const mat = new THREE.ShaderMaterial({
                side: THREE.DoubleSide,
                uniforms: {
                    color1: { value: new THREE.Color("white") },
                    color2: { value: new THREE.Color(0xc3cffc) },
                },
                vertexShader: `
                                varying vec2 vUv;
                                void main() {
                                    vUv = uv;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                                }
                            `,
                fragmentShader: `
                                uniform vec3 color1;
                                uniform vec3 color2;
                                varying vec2 vUv;
                                void main() {
                                    gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
                                }
                            `,
            });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
        }

        function setCircle() {
            // // circle
            // const geometry = new THREE.RingGeometry(10, 14, 70);
            // const material = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0, metalness: 0.5 });
            // circle = new THREE.Mesh(geometry, material);
            // circle.position.y = 0.5;
            // circle.receiveShadow = true;
            // circle.castShadow = true;
            // circle.rotation.x = Math.PI * 0.5;
            // scene.add(circle);

            const geometry = new THREE.RingGeometry(14, 18, 70);
            const groundMirror = new Reflector(geometry, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0xb5b5b5,
            });
            // const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, side: THREE.DoubleSide, roughness: 0, metalness: 0.5 });
            // const groundMirror = new THREE.Mesh(geometry, mat);
            groundMirror.position.y = 0.06;
            groundMirror.rotateX(-Math.PI / 2);
            scene.add(groundMirror);

            let outerR = 18;
            let innerR = 14;
            let h = 0.1;
            let g = cylinderLathe(outerR, innerR, h);
            let m = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, metalness: 0.2, opacity: 0.7, transparent: true });
            circle = new THREE.Mesh(g, m);
            circle.receiveShadow = true;
            circle.castShadow = true;
            scene.add(circle);
            function cylinderLathe(R, r, h) {
                let halfH = h * 0.5;
                let points = [new THREE.Vector2(r, -halfH), new THREE.Vector2(R, -halfH), new THREE.Vector2(R, halfH), new THREE.Vector2(r, halfH), new THREE.Vector2(r, -halfH)];
                let circle = new THREE.LatheGeometry(points, 72);

                return circle;
            }
        }

        function setDrop() {
            function toRadians(degrees) {
                return degrees * (Math.PI / 180);
            }

            // drop
            let obj = {};
            const radius = 16;
            const geometry = new THREE.SphereGeometry(1, 32, 16);
            let material;
            for (var i = 0; i < 360; i += 12) {
                obj.x = radius * Math.cos(toRadians(i));
                obj.y = radius * Math.sin(toRadians(i));

                if (i === 0) {
                    loader.load("data/CuteBox.fbx", (object) => {
                        console.log(object);
                        object.scale.multiplyScalar(0.005);
                        // object.setSize(32, 32);
                        object.position.set(15, 1, 2);

                        // mixer = new THREE.AnimationMixer(object);
                        // const action = mixer.clipAction(object.animations[0]);
                        // action.play();
                        // object.name = "avatar";
                        scene.add(object);
                    });
                } else {
                    if (i > 12 && i < 60) material.opacity = 0.5;
                    material = new THREE.MeshStandardMaterial({ color: `rgb(${parseInt(0.7 * i)}, 70, 255)`, transparent: true });
                    const sphere = new THREE.Mesh(geometry, material);

                    sphere.position.set(obj.x, 1, obj.y);
                    sphere.castShadow = true;
                    sphere.receiveShadow = true;
                    group.add(sphere);
                }
            }
            scene.add(group);
            console.log(group);
        }

        function animate() {
            // if (autoRotate) targetRotationX = 0.0005; // autoRotate Speed
            rotateAroundWorldAxis(group, new THREE.Vector3(0, 1, 0), targetRotationX);
            targetRotationX = targetRotationX * (1 - slowingFactor);
        }

        function render() {
            animate();
            requestAnimationFrame(render);

            // controls.autoRotate = true;
            controls.update();
            renderer.render(scene, camera);
        }

        function rotateAroundWorldAxis(object, axis, radians) {
            var rotationMatrix = new THREE.Matrix4();

            rotationMatrix.makeRotationAxis(axis.normalize(), radians);
            rotationMatrix.multiply(object.matrix); // pre-multiply
            object.matrix = rotationMatrix;
            object.rotation.setFromRotationMatrix(object.matrix);
        }
    </script>
</body>
